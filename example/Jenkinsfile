pipeline {
  agent any

  options {
    skipDefaultCheckout(true) // avoid duplicate SCM checkout
  }

  environment {
    TARGET_NS                 = 'surrounding-systems-dev-axa-magi-id'
    APP_NAME                  = 'virtual-account-snap-mandiri'
    SOLUTION                  = 'JwtApp.sln'
    BC_NAME                   = "${APP_NAME}"
    KUBE_CRED_ID              = 'jenkins-dev-axa-magi-id-kubeconfig'
    GITHUB_CRED               = 'github-ssh-prod'
    ARTIFACTORY_CRED_ID       = 'artifactory-credentials'
    SONAR_PROJECT_KEY         = 'aii_virtual-account-snap-mandiri_40813062-bf3e-4f3b-90ec-29a838de087e'
    SONAR_EXCLUSIONS          = '**/bin/**,**/obj/**,**/TestResults/**,**/building-block-submodule/**,**/cer_file/**'
    SONAR_COVERAGE_EXCLUSIONS = '**/Data/Configurations/**,**/Data/Interceptors/**,**/Program.cs,**/Startup.cs,**/DependencyInjection.cs,**/GlobalSuppressions.cs,**/GlobalUsing.cs,**/Endpoints/**,**/Extensions/**,**/Middlewares/**,**/Properties/**,**/Common/**,**/Entities/**,**/Models/**,**/Migrations/**,**/Controllers/**'
    SONAR_CPD_EXCLUSIONS      = 'src/SnapVA.Infrastructure/Migrations/**'
    SONAR_COVERAGE            = 'TestResults/coverage.opencover.xml'
    SONAR_TIMEOUT             = '120'
  }

  stages {
    stage('ðŸ“¥ Checkout Code') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${env.BRANCH_NAME}"]],
          userRemoteConfigs: [[
            url: 'git@github.axa.com:aii/virtual-account-snap-mandiri.git',
            credentialsId: env.GITHUB_CRED
          ]],
          extensions: [[
            $class: 'SubmoduleOption',
            parentCredentials: true,
            recursiveSubmodules: true
          ]]
        ])

        // Ensure submodules are initialized (correct commands)
        sh '''
          set -eux
          git submodule sync --recursive
          git submodule update --init --recursive
        '''
      }
    }

    stage('ðŸ“¦ Restore NuGet Packages') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: env.ARTIFACTORY_CRED_ID,
          usernameVariable: 'ART_USER',
          passwordVariable: 'ART_PASSWORD'
        )]) {
          sh '''
            set -eux
            dotnet --info

            cat > nuget.config <<EOF
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear/>
    <add key="AXA-Virtual" value="https://artifactory.asia.axa-cloud.com/artifactory/api/nuget/v3/virtual_axa-magi-id_aii-prod-nuget" />
  </packageSources>
  <packageSourceCredentials>
    <AXA-Virtual>
      <add key="Username" value="${ART_USER}" />
      <add key="ClearTextPassword" value="${ART_PASSWORD}" />
    </AXA-Virtual>
  </packageSourceCredentials>
</configuration>
EOF

            dotnet nuget locals http-cache --clear

            dotnet restore "${SOLUTION}" \
              --configfile nuget.config \
              --nologo \
              --verbosity detailed \
              --no-cache \
              --force \
              -p:RestoreUseStaticGraphEvaluation=true \
              -p:RestoreDisableParallel=false
          '''
        }
      }
    }

    stage('ðŸ” Start SonarQube Analysis') {
      steps {
        withSonarQubeEnv('SonarQube') {
          script {
            def sonarArgs = env.CHANGE_ID ? """
              /d:sonar.pullrequest.key=${CHANGE_ID} \
              /d:sonar.pullrequest.branch=${CHANGE_BRANCH} \
              /d:sonar.pullrequest.base=${CHANGE_TARGET}
            """ : "/d:sonar.branch.name=${BRANCH_NAME}"

            sh '''
              set -eux
              
              # Remove any existing sonar-project.properties files that conflict with MSBuild scanner
              find . -name "sonar-project.properties" -type f -delete || true
              echo "Removed any existing sonar-project.properties files"
              
              export PATH="$PATH:/root/.dotnet/tools"
              dotnet tool install --global dotnet-sonarscanner || true
            '''

            sh """
              set -eux
              export PATH="\$PATH:/root/.dotnet/tools"
              dotnet sonarscanner begin /k:"${SONAR_PROJECT_KEY}" \
                ${sonarArgs} \
                /d:sonar.host.url=${SONAR_HOST_URL} \
                /d:sonar.token=${SONAR_AUTH_TOKEN} \
                /d:sonar.projectBaseDir="${WORKSPACE}" \
                /d:sonar.exclusions="${SONAR_EXCLUSIONS}" \
                /d:sonar.coverage.exclusions="${SONAR_COVERAGE_EXCLUSIONS}" \
                /d:sonar.cpd.exclusions="${SONAR_CPD_EXCLUSIONS}" \
                /d:sonar.cs.opencover.reportsPaths="${SONAR_COVERAGE}" \
                /d:sonar.scanner.socketTimeout=${SONAR_TIMEOUT} \
                /d:sonar.scanner.scanAll=false
            """
          }
        }
      }
    }

    stage('âš™ï¸ Build Project') {
      steps {
        sh 'set -eux; dotnet build "${SOLUTION}" -c Release --no-restore'
      }
    }

    stage('ðŸ“Š Parse Test Coverage') {
      steps {
        sh '''
          set -eux
          
          # Create TestResults directory if it doesn't exist
          mkdir -p "${WORKSPACE}/TestResults"
          
          # Look for existing coverage files in the repository
          echo "Searching for existing test coverage files..."
          echo "Current directory: $(pwd)"
          COVERAGE_FILES=$(find . -name "coverage.opencover.xml" -o -name "*.coverage.xml" -o -name "coverage.xml" 2>/dev/null | head -10)
          echo "Found coverage files:"
          echo "$COVERAGE_FILES"
          
          # Also check the content of the first coverage file to validate format
          if [ -n "$COVERAGE_FILES" ]; then
            FIRST_FILE=$(echo "$COVERAGE_FILES" | head -1)
            echo "Checking coverage file format for: $FIRST_FILE"
            head -5 "$FIRST_FILE" || true
          fi
          
          # Copy any existing coverage files to TestResults directory for SonarQube
          if find . -name "coverage.opencover.xml" -print -quit | grep -q .; then
            echo "Found coverage.opencover.xml files, processing for SonarQube..."
            
            # Find the most recent coverage file from the tests directory
            LATEST_COVERAGE=$(find ./tests -name "coverage.opencover.xml" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
            
            if [ -n "$LATEST_COVERAGE" ]; then
              echo "Processing coverage file for SonarQube: $LATEST_COVERAGE"
              
              # Fix absolute paths to relative paths using basic Unix tools
              echo "Converting absolute paths to relative paths for SonarQube..."
              
              # Handle Windows backslash paths - the actual format in the files
              # First convert backslashes to forward slashes, then remove the absolute path prefix
              cat "$LATEST_COVERAGE" | tr '\\' '/' | sed 's|fullPath="[^"]*/virtual-account-snap-mandiri/|fullPath="|g' > "${WORKSPACE}/TestResults/coverage.opencover.xml"
              
              # Validate the fixed file
              echo "Coverage file processed successfully:"
              ls -la "${WORKSPACE}/TestResults/coverage.opencover.xml"
              echo "Sample fixed paths (should be relative with forward slashes):"
              grep -m 3 'fullPath=' "${WORKSPACE}/TestResults/coverage.opencover.xml" | head -3 || true
              
              # Verify file is valid XML and has coverage data
              echo "Coverage statistics from file:"
              grep -o 'sequenceCoverage="[^"]*"' "${WORKSPACE}/TestResults/coverage.opencover.xml" | head -5 || true
              
              # Count the number of files in coverage report
              echo "Number of source files covered:"
              grep -c 'fullPath=' "${WORKSPACE}/TestResults/coverage.opencover.xml" || echo "0"
            else
              echo "Coverage file already exists in TestResults directory"
              ls -la "${WORKSPACE}/TestResults/" || true
            fi
            
          elif find . -name "*.coverage.xml" -print -quit | grep -q .; then
            echo "Found .coverage.xml files, copying to TestResults..."
            LATEST_COVERAGE=$(find . -name "*.coverage.xml" -not -path "./TestResults/*" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
            if [ -n "$LATEST_COVERAGE" ]; then
              cp "$LATEST_COVERAGE" "${WORKSPACE}/TestResults/coverage.opencover.xml"
            fi
            
          elif find . -name "coverage.xml" -print -quit | grep -q .; then
            echo "Found coverage.xml files, copying to TestResults..."
            LATEST_COVERAGE=$(find . -name "coverage.xml" -not -path "./TestResults/*" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
            if [ -n "$LATEST_COVERAGE" ]; then
              cp "$LATEST_COVERAGE" "${WORKSPACE}/TestResults/coverage.opencover.xml"
            fi
          else
            echo "No existing coverage files found in repository"
          fi
          
          # List what we have in TestResults
          echo "Coverage files available for SonarQube:"
          ls -la "${WORKSPACE}/TestResults/" || echo "TestResults directory is empty"
        '''
      }
      post {
        always {
          // Conditionally publish test results if they exist
          script {
            if (fileExists('TestResults/**/*.xml') || fileExists('**/*.trx')) {
              publishTestResults testResultsPattern: 'TestResults/**/*.xml,**/*.trx'
            }
          }
        }
      }
    }

    stage('âœ… Complete SonarQube Analysis') {
      steps {
        withSonarQubeEnv('SonarQube') {
          sh '''
            set -eux
            export PATH="$PATH:/root/.dotnet/tools"
            dotnet sonarscanner end /d:sonar.token="${SONAR_AUTH_TOKEN}"
          '''
        }
      }
    }

    stage('ðŸš¦ Verify Quality Gate') {
      steps {
        timeout(time: 2, unit: 'MINUTES') {
          script {
            def qg = waitForQualityGate()
            if (qg.status != 'OK') {
              error "ðŸš¨ Quality Gate failed: ${qg.status}. See SonarQube for details."
            } else {
              echo "âœ… Quality Gate passed!"
            }
          }
        }
      }
    }

    stage('ðŸš€ Deploy to OpenShift') {
      when {
        expression {
          env.BRANCH_NAME == 'dev' || env.BRANCH_NAME == 'main'
        }
      }
      steps {
        withCredentials([file(credentialsId: env.KUBE_CRED_ID, variable: 'KUBECONFIG')]) {
          sh '''
            set -eux
            chmod 600 "$KUBECONFIG"
            export KUBECONFIG
          '''
          script {
            def buildName = sh(
              script: "oc start-build ${BC_NAME} --follow=false --output=name -n ${TARGET_NS}",
              returnStdout: true
            ).trim()
            echo "â†’ Started build: ${buildName}"
            sh "oc logs -f ${buildName} -n ${TARGET_NS}"
          }
        }
      }
    }
  }

  post {
    success {
      echo "ðŸŽ‰ ${env.APP_NAME} successfully analyzed, passed Quality Gate, and (if on main/dev) deployed to OpenShift."
    }
    failure {
      echo "ðŸš¨ Pipeline failed; check logs above for details."
    }
  }
}
